---
layout: post 
title:  "Reliable Data Transfer Protocol"
date:   2017-09-05 17:50:00 +0800
excerpt_separator: <!--abstract-->
tags: TCP
---

最近一直在看《Computer Networking: A Top-Down Approach》这本书，感觉把自己大学本科时候学的网络知识串了起来，结合当前的运维工作，能更深刻地理解计算机网络。这篇就记录下书中提到的，TCP协议的演进过程。整个思维过程仿佛自己在研发一款协议一样，很启发人，仅做个记录。<!--abstract-->

首先，IP协议是一款不可靠的端到端网络层协议。TCP协议如果要保证可靠性，那么就需要具备一定的处理错误的能力。

## 约定

一些约定以及缩写解释：

```
FSM：Finite Status Machine，有限状态机。
Λ：Lambda，表示此时无动作。
Dash Arror：虚线，表示初始化状态。
rdt：reliable data transfer，可靠的数据传输。
图中横线：横线上方表示状态转变触发动作；横线下方表示出发后的一系列动作

rdt_send(data)：发送方rdt服务从上层接收数据
make_pkt(data)：创建包含data的packet
udt_send(packet)：使用下层不可靠协议发送数据
rdt_rcv(packet)：接收方收到下层传来的数据
extract(packet, data)：从packet中解析data
deliver_data(data)：将data传送到上层
```

## rdt v1.0

假设网络完全可靠，无丢包，无差错情况。

发送方接收到上层发送数据请求，经过传输层封包 `make_pkt`， 并使用下层不可靠协议（当前情形下，假设下层协议可靠）发送数据 `udt_send(packet)`。之后，继续等待上层的发送数据请求。

接收方接收到下层传来的数据，经过解包 `extract(packet, data)` 后，将数据传送到上层 `deliver_data(data)`。之后，继续等待接收下层数据。

rdt v1.0 的发送方和接收方都仅有一个状态。在不考虑效率的情况下，双方在处理完一次请求后就阻塞，等待下次处理请求。

![rdt v1.0](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt1.png)

## rdt v2.0

现实中，网络不可能完全可靠。假设下层信道在传输过程中，会导致包内数据产生数据差错(corrupted)（但不出现丢包）的情形。

例如：某个为 1 的比特，传输过程中变成了 0，则接收方无法解析正确的数据。

拿一个现实中的例子来说，两个人聊天，A说了一句话，B听懂了。B回复 "OK"；否则，B会请求A重说一次 "Please repeat it."。

类似地，我们引入 ACK(positive acknowledgments) 和 NAK(negative acknowledgments)。当接收方正确接收信息，回复ACK；否则，回复NAK，而此时，发送方会重传数据。这类重传协议，也称为 ARQ(Automatic Repeat reQuest) protocols.

ARQ协议会引入三类机制，来支持重传功能：


1. 错误检测
	- 类似 UDP 的 checksum 方式，来检测错误。
2. 接收反馈
	- 通过 ACK 和 NAK 进行反馈
3. 重传
	- 发送方接收到 NAK 后，对数据进行重传。


rdt v2.0情形下，发送方会有两个状态：


1. 等待上层调用状态
	- 一旦上层调用发送数据接口 `rdt_send(data)` ，发送数据后变为等待反馈状态。
2. 等待反馈状态
	- 当接受到反馈：ACK 情形下，表示正确接收数据，状态转变为等待调用；NAK 情形下，重传数据，继续等待反馈。


接收方仅有一个状态：

等待接收下层协议数据。如果检测到错误，则返回 NAK；如果检测正确，则返回 ACK。

![rdt v2.0](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt2.png)

## rdt v2.1

但是，rdt v2.0有一个致命的缺陷，即：如果 NAK 或 ACK 出现数据差错(corrupted)，接收方将收到一个不知是 NAK 还是 ACK 的反馈数据包。

这种情形下，该如何处理 NAK/ACK 包的差错问题呢？

1. 当发送方接收到非 NAK/ACK 的包时，回复 "What do you say?" 包，此时，接收方重传反馈包。那么问题来了，当这个 "What do you say?" 包异常时，该怎么办呢？继续发送 "What do sender say？" 包吗？明显，这将无限循环下去，并不是一个好的解决办法。

2. 在反馈包中，增加纠错位。当发送方接收到非 NAK/ACK 的包时，不仅能检验出错误，而且可以通过纠错位，纠正错误。在当前情形来看，这种方案是能解决问题的。但考虑到现实网络会有丢包的情形，如果丢包了，发送方将一直阻塞下去，还是无法满足需求。

3. 第三种方法，当收到无法解析的 NAK/ACK 包时，发送方再次重传数据包。但这引入了 "重复数据包" 的问题，接收方不知道它之前发送的 NAK 或 ACK 是否被发送方正确接收。因此，接收方不知道本次接收的数据，是一个新包，还是和之前包的内容一致。

比较简单的解决办法是：给数据包中，增加一个 **序列号** 。接收方仅需要检验序列号位，来决定是丢弃还是使用该数据包。序列号为：0 和 1。

rdt v2.1的发送方有四个状态：

1. 等待发送数据包 0：
	- 发送序列号为 0 的包，携带校验和。
2. 等待 ACK/NAK 0：
	- 接收到 NAK 0 时，重传数据 0。
	- 接收到 ACK 0 时，进入下一状态。
3. 等待发送数据包 1：
	- 发送序列号为 1 的包，携带校验和。
4. 等待 ACK/NAK 1:
	- 接收到 NAK 1 时，重传数据 1。
	- 接收到 ACK 1 时，回到状态1。

![rdt v2.1_s](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt2.1_s.png)


接收方有两个状态：


1. 等待接收数据包 0：
	- 接收数据包 0，正常，发送 ACK 0，进入下一状态。
	- 异常，发送 NAK 0，阻塞在当前状态。
2. 等待接收数据包 1：
	- 接收数据包 1，正常，发送 ACK 1，回到之前状态。
	- 异常，发送 NAK 1，阻塞在当前状态。

![rdt v2.1_r](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt2.1_r.png)

## rdt v2.2

由于引入了 序列号 ，则接收方无需使用 NAK 来标记错误。当接收到错误包时，接收方仅需回复 ACK + 正确接收的最后一个包的序列号 i，发送方重传序列号为 (i+1) % 2 的包。

发送方收到重复的 ACK + i 时，认为数据包 i 出错，重传数据包 i。

rdt v2.2 通过重传 ACK，来放弃使用 NAK 包。状态机类似 rdt v2.1，粗体部分为与 rdt v2.1的差别：

rdt v2.2的发送方有四个状态：


1. 等待发送数据包 0：
	- 发送序列号为 0 的包，携带校验和。
2. 等待 ACK 0：
	- 接收到 ACK 1 时，重传数据 0。
	- 接收到 **ACK 0** 时，进入下一状态。
3. 等待发送数据包 1：
	- 发送序列号为 1 的包，携带校验和。
4. 等待 ACK 1:
	- 接收到 ACK 0 时，重传数据 1。
	- 接收到 **ACK 1** 时，回到状态1。

![rdt v2.2_s](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt2.2_s.png)

接收方有两个状态：


1. 等待接收数据包 0：
	- 接收数据包 0，正常，发送 ACK 0，进入下一状态。
	- 异常，发送 **ACK 1**，阻塞在当前状态。
2. 等待接收数据包 1：
	- 接收数据包 1，正常，发送 ACK 1，回到之前状态。
	- 异常，发送 **ACK 0**，阻塞在当前状态。

![rdt v2.2_r](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt2.2_r.png)


## rdt v3.0

在 v3.0 版本，我们考虑下层传输过程，有丢包的情况。

发送方发送的数据，或者接收方发送的 ACK 包，都有可能丢失。发送方等待一个足够长的时间，之后确认数据确实丢失，进而重传数据包。一般等待一个 RTT(Round-Trip Time) 是比较合理的。

如果发送的数据和 ACK 都没丢，仅是延迟比较大，超过 RTT，那么 rdt v2.2 版本也保证了重发包不会引起异常。

基于超时的重传机制，需要在发送方，引入一个计时器。当计时器超时后，通知发送方，重传之前的数据。

rdt v3.0 状态机：

发送方：

1. 等待发送数据包 0：
	- 接收到回复包时， Do nothing。
	- 发送序列号为 0 的包，携带校验和，启动计时器。
2. 等待 ACK 0：
	- 接收到 ACK 1 或 包校验出错 时，Do nothing。
	- 超时，重传包，并重新启动计时器。
	- 接收到包，包校验正常且是 ACK 0 时，进入下一状态。
3. 等待发送数据包 1：
	- 接收到回复包时， Do nothing。
	- 发送序列号为 1 的包，携带校验和，启动计时器。
4. 等待 ACK/NAK 1:
	- 接收到 ACK 0 或 包校验出错 时，Do nothing。
	- 超时，重传包，并重新启动计时器。
	- 接收到包，包校验正常且是 ACK 1 时，回到状态1。

![rdt v3.0_s](../../../assets/2017-09-06-reliable-data-transfer-protocol/rdt3.0_s.png)

接收方：

接收方状态类似 rdt v2.2 版本，不再赘述。

## Pipelined Reliable Data Transfer Protocols

实际应用中，阻塞式的传输协议效率太低，无法满足今天高速网络的需求。

例如：A、B两地，带宽为 R = 1Gbps，RTT = 30ms，如果每个packet大小为 1KB = 8000 bits 数据。那么，一个包的最后一bit进入网络的时间是 8微秒。传输过程耗时 30毫秒。

那么传输效率为 0.008 / (30 + 0.008) = 0.00027

99.97%的时间，都在等待包传输，效率极低。

那么就要求协议允许发送方同时传输多个包，那么协议需要引入如下机制：

1. 包序列号范围需要增加。
2. 发送方和接收方 buffer 更大，能够缓存更多数据。
3. 序列号范围和缓存大小需要匹配。

GBN(Go Back N) 和 SR(Selective Repeat) 两种方式可以用来解决阻塞式传输协议的问题。

## GBN

GBN是一个滑动窗口协议，每个数据包，包含一个序列号，新发送的包序列号加一。每次发送 N 个数据包，等待接收方返回 N 个 ACK，再继续发送 N 个数据包。

N 常称为 **窗口大小** ，在之后的 **流量控制** 部分，将讨论 N 大小的问题。

如果 N 个包中，第 i 个包没有正确接收到 ACK，则 [i+1, N] 这些包，都要重新传输，窗口向后滑动 i 个序列号。同时，接收方会丢弃序列号为 [i+1, N] 的包，并返回 ACK + i-1，其中，i-1 为最近成功接收包的序列号。

![gbn](../../../assets/2017-09-06-reliable-data-transfer-protocol/gbn.png)

## SR

SR 是选择重传协议。同 GBN 类似，SR 每次也发送 N 个数据包，当第 i 个包传输异常时，如果序列号为 [i+1, N] 的包被正确传输，接收方缓存这些包，并回复相应的 ACK + 序列号。

发送方第 i 个包超时后，重传序列号为 i 开始的 N 个数据包。

![sr](../../../assets/2017-09-06-reliable-data-transfer-protocol/sr.png)

#### 问题

假设窗口大小为 N ，序列号范围为 [0, M]，且 N = M 时，**选择重传协议会出问题**。下面，我们举个例子：

```

N = 3
M = 3 即，序列号为：0，1，2，3
S 为发送方；R 为接收方

N = 3，故 S 发送 0，1，2 三个包，R 正确接收，返回 0，1，2 的 ACK

考虑如下两种情形：
1. ACK 0，1，2被 S 正确接收。S 发送 3，0，1 三个包，序列号为 3 的包丢失，而 0 正确接收，**且 0 为一个新包**，R 返回 ACK0 。
2. ACK 0，1，2均未被 S 正确接收。S 发送 0，1，2三个包。当 R 收到 0 包时，**0 包为一个旧包**，R 返回 ACK0 。

这时，无法判断 ACK0 是新包的 ACK，还是老包的 ACK。

```

![sr_large_window](../../../assets/2017-09-06-reliable-data-transfer-protocol/sr_large_window.png)


建议窗口大小 N <= (M+1)/2

## 总结

至此，一个初见雏形的 rdt 协议出炉了。通过 接收方反馈(ACK)、包序列号、计时器、重传 等机制，克服了下层协议的 丢包、包异常 等情形，具有较高的性能。

下篇文章，我们继续学习 TCP 的流量控制和拥塞控制，以及三次握手、四次挥手和各阶段的状态。

***


参考资料
1. 《Computer Networking: A Top-Down Approach》
